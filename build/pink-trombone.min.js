/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./script/audio/nodes/constantSource/AudioNode.js
/*
    TODO
        define custom value setters
*/
Math.clamp = function (value, min, max) {
  return value <= min ? min : value < max ? value : max;
};

Math.interpolate = function (interpolation, from, to) {
  interpolation = Math.clamp(interpolation, 0, 1);
  return from * (1 - interpolation) + to * interpolation;
};

window.AudioContext = window.AudioContext || window.webkitAudioContext;

if (window.AudioContext.prototype.createConstantSource == undefined) {
  window.AudioContext.prototype.createConstantSource = function () {
    var constantSourceNode = this.createScriptProcessor(Math.pow(2, 14), 1, 1);
    constantSourceNode._isRunning = false;
    constantSourceNode._audioContext = this;
    constantSourceNode.offset = constantSourceNode;
    constantSourceNode.__interpolationMode = "none";
    Object.defineProperty(constantSourceNode, "_interpolationMode", {
      get: function get() {
        return this.__interpolationMode;
      },
      set: function set(newValue) {
        if (["none", "linear"].includes(newValue)) this.__interpolationMode = newValue;
      }
    });
    constantSourceNode._startValue;
    constantSourceNode._targetValue;
    constantSourceNode._startTime;
    constantSourceNode._targetTime;
    constantSourceNode._duration;
    constantSourceNode.minValue = -3.402820018375656e+38;
    constantSourceNode.maxValue = +3.402820018375656e+38;

    constantSourceNode._clamp = function (newValue) {
      return Math.clamp(newValue, this.minValue, this.maxValue);
    };

    constantSourceNode._update = function () {
      if (this._interpolationMode !== "none") {
        var timeOffset = this._audioContext.currentTime - this._startTime;
        var linearInterpolation = timeOffset / this._duration;
        var interpolation = linearInterpolation;

        switch (this._interpolationMode) {
          case "linear":
            interpolation = linearInterpolation;
            break;

          default:
            break;
        }

        interpolation = Math.clamp(interpolation, 0, 1);
        this._value = this._clamp(Math.interpolate(interpolation, this._startValue, this._targetValue));
        if (interpolation >= 1) this._interpolationMode = "none";
      }
    };

    constantSourceNode._value = 1;
    Object.defineProperty(constantSourceNode, "value", {
      get: function get() {
        return this._value;
      },
      set: function set(newValue) {
        this._interpolationMode = "none";
        this._value = Math.clamp(newValue, this.minValue, this.maxValue);
      }
    });

    constantSourceNode.linearRampToValueAtTime = function (value, time) {
      // FILL
      this.value = value;
      return this;
    };

    constantSourceNode.setValueAtTime = function (value, time) {
      // FILL
      this.value = value;
      return this;
    };

    constantSourceNode.exponentialRampToValueAtTime = function (value, time) {
      // FILL
      this.value = value;
      return this;
    };

    constantSourceNode.setTargetAtTime = function (value, time, timeConstant) {
      // FILL
      this.value = value;
      return this;
    };

    constantSourceNode.setValueAtTime = function (value, time) {
      // FILL
      this.value = value;
      return this;
    };

    constantSourceNode.setValueCurveAtTime = function (value, time, duration) {
      // FILL
      this.value = value;
      return this;
    };

    constantSourceNode.onaudioprocess = function (event) {
      var inputChannel = event.inputBuffer.getChannelData(0);
      var outputChannel = event.outputBuffer.getChannelData(0);
      if (this._isRunning) for (var sampleIndex = 0; sampleIndex < outputChannel.length; sampleIndex++) {
        this._update();

        outputChannel[sampleIndex] = inputChannel[sampleIndex] + this.value;
      }
    };

    constantSourceNode.start = function () {
      this._isRunning = true;
    };

    constantSourceNode.stop = function () {
      this._isRunning = false;
    };

    return constantSourceNode;
  };
}


// CONCATENATED MODULE: ./script/audio/nodes/noise/AudioNode.js
/*
    TODO
        .type property that allows for different noise types (white noise, pink noise, etc)
*/
window.AudioContext = window.AudioContext || window.webkitAudioContext;

window.AudioContext.prototype.createNoise = function () {
  var noiseNode = this.createBufferSource();
  var seconds = 1;
  var buffer = this.createBuffer(1, seconds * this.sampleRate, this.sampleRate);
  var bufferChannel = buffer.getChannelData(0);

  for (var sampleIndex = 0; sampleIndex < bufferChannel.length; sampleIndex++) {
    bufferChannel[sampleIndex] = Math.random(0) * 2 - 1;
  }

  noiseNode.buffer = buffer;
  noiseNode.loop = true;
  noiseNode.start();
  return noiseNode;
};


// CONCATENATED MODULE: ./script/audio/nodes/pinkTrombone/processors/ParameterDescriptors.js
var ParameterDescriptors = [{
  name: "noise",
  defaultValue: 0,
  minValue: -1,
  maxValue: 1
}, {
  name: "frequency",
  defaultValue: 140,
  minValue: 0
}, {
  name: "tenseness",
  defaultValue: 0.6,
  minValue: 0,
  maxValue: 1
}, {
  name: "intensity",
  defaultValue: 1,
  minValue: 0,
  maxValue: 1
}, {
  name: "loudness",
  defaultValue: 1,
  minValue: 0,
  maxValue: 1
}, {
  name: "tongueIndex",
  defaultValue: 12.9 //automationRate : "k-rate",

}, {
  name: "tongueDiameter",
  defaultValue: 2.43 //automationRate : "k-rate",

}, {
  name: "vibratoWobble",
  defaultValue: 1,
  minValue: 0,
  maxValue: 1
}, {
  name: "vibratoFrequency",
  defaultValue: 6,
  minValue: 0
}, {
  name: "vibratoGain",
  defaultValue: 0.005,
  minValue: 0
}];
ParameterDescriptors.numberOfConstrictions = 4;

for (var ParameterDescriptors_index = 0; ParameterDescriptors_index < ParameterDescriptors.numberOfConstrictions; ParameterDescriptors_index++) {
  var constrictionParameterDescriptors = [{
    name: "constriction" + ParameterDescriptors_index + "index",
    defaultValue: 0,
    automationRate: "k-rate"
  }, {
    name: "constriction" + ParameterDescriptors_index + "diameter",
    defaultValue: 0,
    automationRate: "k-rate"
  }];
  ParameterDescriptors.push.apply(ParameterDescriptors, constrictionParameterDescriptors);
}

/* harmony default export */ var processors_ParameterDescriptors = (ParameterDescriptors);
// CONCATENATED MODULE: ./script/audio/nodes/pinkTrombone/processors/SimplexNoise.js
function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

// VECTOR 3
function Vector3() {
  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  this.x = x;
  this.y = y;
  this.z = z;
}

Object.defineProperties(Vector3.prototype, {
  dot2: {
    value: function value(x, y) {
      return this.x * x + this.y * y;
    }
  },
  dot3: {
    value: function value(x, y, z) {
      return this.dot2(x, y) + this.z * z;
    }
  }
}); //////////////////////////////////////////////////////////////////////
// SIMPLEX NOISE

function SimplexNoise() {
  this.grad3 = [[+1, +1, +0], [-1, +1, +0], [+1, -1, +0], [-1, -1, +0], [+1, +0, +1], [-1, +0, +1], [+1, +0, -1], [-1, +0, -1], [+0, +1, +1], [+0, -1, +1], [+0, +1, -1], [+0, -1, -1]].map(function (vector3Arguments) {
    return _construct(Vector3, _toConsumableArray(vector3Arguments));
  });
  this.p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];
  this.perm = new Array(Math.pow(2, 8 + 1));
  this.gradP = new Array(Math.pow(2, 8 + 1));
  this.F2 = 0.5 * (Math.sqrt(3) - 1);
  this.G2 = (3 - Math.sqrt(3)) / 6;
  this.F3 = 1 / 3;
  this.G3 = 1 / 6;
  this.seed(Date.now());
}

Object.defineProperties(SimplexNoise.prototype, {
  seed: {
    value: function value(seed) {
      if (seed > 0 && seed < 1) seed *= Math.pow(2, 16);
      seed = Math.floor(seed);
      if (seed < Math.pow(2, 8)) seed |= seed << Math.pow(2, 3);

      for (var index = 0; index < Math.pow(2, 8); index++) {
        var seedShift = index & 1 ? 0 : Math.pow(2, 3);
        var value = this.p[index] ^ seed >> seedShift & Math.pow(2, 8) - 1;
        this.perm[index] = this.perm[index + Math.pow(2, 8)] = value;
        this.gradP[index] = this.gradP[index + Math.pow(2, 8)] = this.grad3[value % this.grad3.length];
      }
    }
  },
  simplex2: {
    value: function value(xin, yin) {
      var s = (xin + yin) * this.F2;
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var t = (i + j) * this.G2;
      var x0 = xin - i + t;
      var y0 = yin - j + t;
      var i1 = x0 > y0 ? 1 : 0;
      var j1 = 1 - i1;
      var x1 = x0 - i1 + this.G2;
      var y1 = y0 - j1 + this.G2;
      var x2 = x0 - 1 + 2 * this.G2;
      var y2 = y0 - 1 + 2 * this.G2;
      i &= Math.pow(2, 8) - 1;
      j &= Math.pow(2, 8) - 1;
      var gi0 = this.gradP[i + this.perm[j]];
      var gi1 = this.gradP[i + i1 + this.perm[j + j1]];
      var gi2 = this.gradP[i + 1 + this.perm[j + 1]];
      var t0 = 0.5 - Math.pow(x0, 2) - Math.pow(y0, 2);
      var n0 = t0 < 0 ? 0 : Math.pow(t0, 4) * gi0.dot2(x0, y0);
      var t1 = 0.5 - Math.pow(x1, 2) - Math.pow(y1, 2);
      var n1 = t1 < 0 ? 0 : Math.pow(t1, 4) * gi1.dot2(x1, y1);
      var t2 = 0.5 - Math.pow(x2, 2) - Math.pow(y2, 2);
      var n2 = t2 < 0 ? 0 : Math.pow(t2, 4) * gi2.dot2(x2, y2);
      return 70 * (n0 + n1 + n2);
    }
  },
  simplex1: {
    value: function value(x) {
      return this.simplex2(x * 1.2, -(x * 0.7));
    }
  }
});
/* harmony default export */ var processors_SimplexNoise = (SimplexNoise);
// CONCATENATED MODULE: ./script/audio/nodes/pinkTrombone/processors/Glottis.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*
    TODO
        *
*/
Math.clamp = function (value, min, max) {
  if (value <= min) return min;else if (value < max) return value;else return max;
};



var Glottis_Glottis =
/*#__PURE__*/
function () {
  function Glottis() {
    _classCallCheck(this, Glottis);

    this.noise = new processors_SimplexNoise();
    this.coefficients = {
      alpha: 0,
      Delta: 0,
      E0: 0,
      epsilon: 0,
      omega: 0,
      shift: 0,
      Te: 0
    };
    this.startSeconds = 0;
  }

  _createClass(Glottis, [{
    key: "process",
    value: function process(parameterSamples, sampleIndex, bufferLength, seconds) {
      var intensity = parameterSamples.intensity;
      var loudness = parameterSamples.loudness;
      var vibrato = 0;
      vibrato += parameterSamples.vibratoGain * Math.sin(2 * Math.PI * seconds * parameterSamples.vibratoFrequency);
      vibrato += 0.02 * this.noise.simplex1(seconds * 4.07);
      vibrato += 0.04 * this.noise.simplex1(seconds * 2.15);

      if (parameterSamples.vibratoWobble > 0) {
        var wobble = 0;
        wobble += 0.2 * this.noise.simplex1(seconds * 0.98);
        wobble += 0.4 * this.noise.simplex1(seconds * 0.50);
        vibrato += wobble * parameterSamples.vibratoWobble;
      }

      var frequency = parameterSamples.frequency;
      frequency *= 1 + vibrato;
      var tenseness = parameterSamples.tenseness;
      tenseness += 0.10 * this.noise.simplex1(seconds * 0.46);
      tenseness += 0.05 * this.noise.simplex1(seconds * 0.36);
      tenseness += (3 - tenseness) * (1 - intensity); // waveform.update()

      var period = 1 / frequency;
      var secondsOffset = seconds - this.startSeconds;
      var interpolation = secondsOffset / period;

      if (interpolation >= 1) {
        this.startSeconds = seconds + secondsOffset % period;
        interpolation = this.startSeconds / period;

        this._updateCoefficients(tenseness);
      } // process


      var outputSample = 0;

      var noiseModulator = this._getNoiseModulator(interpolation);

      noiseModulator += (1 - tenseness * intensity) * 3;
      parameterSamples.noiseModulator = noiseModulator;
      var noise = parameterSamples.noise;
      noise *= noiseModulator;
      noise *= intensity;
      noise *= intensity;
      noise *= 1 - Math.sqrt(Math.max(tenseness, 0));
      noise *= 0.02 * this.noise.simplex1(seconds * 1.99) + 0.2;

      var voice = this._getNormalizedWaveform(interpolation);

      voice *= intensity;
      voice *= loudness;
      outputSample = noise + voice;
      outputSample *= intensity;
      return outputSample;
    }
  }, {
    key: "update",
    value: function update() {}
  }, {
    key: "_updateCoefficients",
    value: function _updateCoefficients() {
      var tenseness = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var R = {};
      R.d = Math.clamp(3 * (1 - tenseness), 0.5, 2.7);
      R.a = -0.01 + 0.048 * R.d;
      R.k = 0.224 + 0.118 * R.d;
      R.g = R.k / 4 * (0.5 + 1.2 * R.k) / (0.11 * R.d - R.a * (0.5 + 1.2 * R.k));
      var T = {};
      T.a = R.a;
      T.p = 1 / (2 * R.g);
      T.e = T.p + T.p * R.k;
      this.coefficients.epsilon = 1 / T.a;
      this.coefficients.shift = Math.exp(-this.coefficients.epsilon * (1 - T.e));
      this.coefficients.Delta = 1 - this.coefficients.shift;
      var integral = {};
      integral.RHS = (1 / this.coefficients.epsilon * (this.coefficients.shift - 1) + (1 - T.e) * this.coefficients.shift) / this.coefficients.Delta;
      integral.total = {};
      integral.total.lower = -(T.e - T.p) / 2 + integral.RHS;
      integral.total.upper = -integral.total.lower;
      this.coefficients.omega = Math.PI / T.p;
      var s = Math.sin(this.coefficients.omega * T.e);
      var y = -Math.PI * s * integral.total.upper / (T.p * 2);
      var z = Math.log(y);
      this.coefficients.alpha = z / (T.p / 2 - T.e);
      this.coefficients.E0 = -1 / (s * Math.exp(this.coefficients.alpha * T.e));
      this.coefficients.Te = T.e;
    }
  }, {
    key: "_getNormalizedWaveform",
    value: function _getNormalizedWaveform(interpolation) {
      return interpolation > this.coefficients.Te ? (-Math.exp(-this.coefficients.epsilon * (interpolation - this.coefficients.Te)) + this.coefficients.shift) / this.coefficients.Delta : this.coefficients.E0 * Math.exp(this.coefficients.alpha * interpolation) * Math.sin(this.coefficients.omega * interpolation);
    }
  }, {
    key: "_getNoiseModulator",
    value: function _getNoiseModulator(interpolation) {
      var angle = 2 * Math.PI * interpolation;
      var amplitude = Math.sin(angle);
      var positiveAmplitude = Math.max(0, amplitude);
      var offset = 0.1;
      var gain = 0.2;
      var noiseModulator = positiveAmplitude * gain + offset;
      return noiseModulator;
    }
  }]);

  return Glottis;
}();

/* harmony default export */ var processors_Glottis = (Glottis_Glottis);
// CONCATENATED MODULE: ./script/audio/nodes/pinkTrombone/processors/Nose.js
function Nose_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
    TODO
        *
*/
var Nose = function Nose(tract) {
  Nose_classCallCheck(this, Nose);

  this.length = Math.floor(28 * tract.length / 44);
  this.start = tract.length - this.length + 1;
  this.fade = 1;
  this.offset = 0.8; // buffers

  this.left = new Float64Array(this.length);
  this.left.junction = new Float64Array(this.length + 1);
  this.right = new Float64Array(this.length);
  this.right.junction = new Float64Array(this.length + 1);
  this.reflection = new Float64Array(this.length + 1);
  this.reflection.value = 0;
  this.reflection["new"] = 0;
  this.diameter = new Float64Array(this.length);
  this.amplitude = new Float64Array(this.length);
  this.amplitude.max = new Float64Array(this.length); // setup

  for (var index = 0; index < this.length; index++) {
    var interpolation = index / this.length;
    var value = interpolation < 0.5 ? 0.4 + 1.6 * (2 * interpolation) : 0.5 + 1.5 * (2 - 2 * interpolation);
    this.diameter[index] = Math.min(value, 1.9);
  }

  for (var _index = 0; _index < this.length; _index++) {
    this.amplitude[_index] = Math.pow(this.diameter[_index], 2);
    if (_index > 0) this.reflection[_index] = (this.amplitude[_index - 1] - this.amplitude[_index]) / (this.amplitude[_index - 1] + this.amplitude[_index]);
  }

  this.diameter[0] = tract.velum.target;
};

/* harmony default export */ var processors_Nose = (Nose);
// CONCATENATED MODULE: ./script/audio/nodes/pinkTrombone/processors/Transient.js
function Transient_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Transient_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Transient_createClass(Constructor, protoProps, staticProps) { if (protoProps) Transient_defineProperties(Constructor.prototype, protoProps); if (staticProps) Transient_defineProperties(Constructor, staticProps); return Constructor; }

var Transient =
/*#__PURE__*/
function () {
  function Transient(position, seconds) {
    Transient_classCallCheck(this, Transient);

    this.position = position;
    this.startTime = seconds;
    this.timeAlive = 0;
    this.lifetime = 0.2;
    this.strength = 0.3;
    this.exponent = 200;
  }

  Transient_createClass(Transient, [{
    key: "update",
    value: function update(seconds) {
      this.timeAlive = seconds - this.startTime;
    }
  }, {
    key: "amplitude",
    get: function get() {
      return this.strength * Math.pow(-2, this.timeAlive * this.exponent);
    }
  }, {
    key: "isAlive",
    get: function get() {
      return this.timeAlive < this.lifetime;
    }
  }]);

  return Transient;
}();

/* harmony default export */ var processors_Transient = (Transient);
// CONCATENATED MODULE: ./script/audio/nodes/pinkTrombone/processors/Tract.js
function Tract_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tract_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tract_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tract_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tract_defineProperties(Constructor, staticProps); return Constructor; }

/*
    TODO
        using tongue as a k-rate constriction
*/



Math.interpolate = function (interpolation, from, to) {
  return from * (1 - interpolation) + to * interpolation;
};

Math.clamp = function (value, minValue, maxValue) {
  return value <= minValue ? minValue : value < maxValue ? value : maxValue;
};

var Tract_Tract =
/*#__PURE__*/
function () {
  function Tract() {
    var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 44;

    Tract_classCallCheck(this, Tract);

    this.length = length; // Indices

    this.blade = {
      start: Math.floor(10 * this.length / 44)
    };
    this.tip = {
      start: Math.floor(32 * this.length / 44)
    };
    this.lip = {
      start: Math.floor(39 * this.length / 44),
      reflection: -0.85
    };
    this.glottis = {
      reflection: 0.75
    };
    this.velum = {
      target: 0.01
    };
    this.grid = {
      offset: 1.7
    }; // Buffers

    this.right = new Float64Array(this.length);
    this.right.junction = new Float64Array(this.length + 1);
    this.right.reflection = {
      value: 0,
      "new": 0
    };
    this.left = new Float64Array(this.length);
    this.left.junction = new Float64Array(this.length + 1);
    this.left.reflection = {
      value: 0,
      "new": 0
    };
    this.reflection = new Float64Array(this.length + 1);
    this.reflection["new"] = new Float64Array(this.length + 1);
    this.amplitude = new Float64Array(this.length);
    this.amplitude.max = new Float64Array(this.length);
    this.diameter = new Float64Array(this.length);
    this.diameter.rest = new Float64Array(this.length); // Tongue & Nose

    this.tongue = {
      _diameter: 2.43,
      _index: 12.9,
      range: {
        diameter: {
          minValue: 2.05,
          maxValue: 3.5,

          get range() {
            return this.maxValue - this.minValue;
          },

          get center() {
            return (this.maxValue + this.minValue) / 2;
          },

          interpolation: function interpolation(diameterValue) {
            var interpolation = (diameterValue - this.minValue) / this.range;
            return Math.clamp(interpolation, 0, 1);
          }
        },
        index: {
          minValue: this.blade.start + 2,
          maxValue: this.tip.start - 3,

          get range() {
            return this.maxValue - this.minValue;
          },

          get center() {
            return (this.maxValue + this.minValue) / 2;
          },

          centerOffset: function centerOffset(interpolation) {
            var centerOffsetDiameter = interpolation * this.range;
            var centerOffsetRadius = centerOffsetDiameter / 2;
            return centerOffsetRadius;
          }
        }
      },

      get diameter() {
        return this._diameter;
      },

      set diameter(newValue) {
        this._diameter = Math.clamp(newValue, this.range.diameter.minValue, this.range.diameter.maxValue);
      },

      get index() {
        return this._index;
      },

      set index(newValue) {
        var diameterInterpolation = this.range.diameter.interpolation(this.diameter);
        var invertedDiameterInterpolation = 1 - diameterInterpolation;
        var straightenedInterpolation = Math.pow(invertedDiameterInterpolation, 0.58) - 0.2 * (Math.pow(invertedDiameterInterpolation, 2) - invertedDiameterInterpolation);
        var centerOffset = this.range.index.centerOffset(straightenedInterpolation);
        this._index = true ? Math.clamp(newValue, this.range.index.center - centerOffset, this.range.index.center + centerOffset) : undefined;
      }

    }; // NOSE

    this.nose = new processors_Nose(this); // Transients

    this.transients = [];
    this.transients.obstruction = {
      last: -1,
      "new": -1
    }; // Constrictions

    this.previousConstrictions = [];
    this.previousConstrictions.tongue = {}; // diameter.update

    for (var index = 0; index < this.length; index++) {
      var value = 0;
      if (index < 7 * this.length / 44 - 0.5) value = 0.6;else if (index < 12 * this.length / 44) value = 1.1;else value = 1.5;
      this.diameter[index] = value;
      this.diameter.rest[index] = value;
    }

    this._updateReflection();
  } // PROCESS


  Tract_createClass(Tract, [{
    key: "process",
    value: function process(parameterSamples, sampleIndex, bufferLength, seconds) {
      this.tongue.diameter = parameterSamples.tongueDiameter;
      this.tongue.index = parameterSamples.tongueIndex;

      this._processTransients(seconds);

      this._processConstrictions(this.previousConstrictions, parameterSamples);

      var bufferInterpolation = sampleIndex / bufferLength;
      var updateAmplitudes = Math.random() < 0.1;
      var outputSample = 0;
      outputSample += this._processLips(parameterSamples, bufferInterpolation, updateAmplitudes);
      outputSample += this._processNose(parameterSamples, bufferInterpolation, updateAmplitudes);
      if (isNaN(outputSample)) this.reset();
      return outputSample;
    }
  }, {
    key: "_processTransients",
    value: function _processTransients(seconds) {
      for (var index = this.transients.length - 1; index >= 0; index--) {
        var _transient = this.transients[index];
        this.left[_transient.position] += _transient.amplitude;

        _transient.update(seconds);

        if (!_transient.isAlive) this.transients.splice(index, 1);
      }
    }
  }, {
    key: "_processConstrictions",
    value: function _processConstrictions(constrictions, parameterSamples) {
      for (var index = 0; index < constrictions.length; index++) {
        var constriction = constrictions[index];

        if (constriction.index >= 2 && constriction.index <= this.length && constriction.diameter > 0) {
          var noise = parameterSamples.glottis;
          var noiseScalar = parameterSamples.noiseModulator * 0.66;
          noise *= noiseScalar;
          var thinness = Math.clamp(8 * (0.7 - constriction.diameter), 0, 1);
          var openness = Math.clamp(30 * (constriction.diameter - 0.3), 0, 1);

          var _ness = thinness * openness;

          noise *= _ness / 2;
          var lowerIndex = Math.floor(constriction.index);
          var lowerWeight = constriction.index - lowerIndex;
          var lowerNoise = noise * lowerWeight;
          var upperIndex = lowerIndex + 1;
          var upperWeight = upperIndex - constriction.index;
          var upperNoise = noise * upperWeight;
          this.right[lowerIndex + 1] += lowerNoise;
          this.right[upperIndex + 1] += upperNoise;
          this.left[lowerIndex + 1] += lowerNoise;
          this.left[upperIndex + 1] += upperNoise;
        }
      }
    }
  }, {
    key: "_processLips",
    value: function _processLips(parameterSamples, bufferInterpolation, updateAmplitudes) {
      this.right.junction[0] = this.left[0] * this.glottis.reflection + parameterSamples.glottis;
      this.left.junction[this.length] = this.right[this.length - 1] * this.lip.reflection;

      for (var index = 1; index < this.length; index++) {
        var interpolation = Math.interpolate(bufferInterpolation, this.reflection[index], this.reflection["new"][index]);
        var offset = interpolation * (this.right[index - 1] + this.left[index]);
        this.right.junction[index] = this.right[index - 1] - offset;
        this.left.junction[index] = this.left[index] + offset;
      }

      var leftInterpolation = Math.interpolate(bufferInterpolation, this.left.reflection["new"], this.left.reflection.value);
      this.left.junction[this.nose.start] = leftInterpolation * this.right[this.nose.start - 1] + (leftInterpolation + 1) * (this.nose.left[0] + this.left[this.nose.start]);
      var rightInterpolation = Math.interpolate(bufferInterpolation, this.right.reflection["new"], this.right.reflection.value);
      this.right.junction[this.nose.start] = rightInterpolation * this.left[this.nose.start] + (rightInterpolation + 1) * (this.nose.left[0] + this.right[this.nose.start - 1]);
      var noseInterpolation = Math.interpolate(bufferInterpolation, this.nose.reflection["new"], this.nose.reflection.value);
      this.nose.right.junction[0] = noseInterpolation * this.nose.left[0] + (noseInterpolation + 1) * (this.left[this.nose.start] + this.right[this.nose.start - 1]);

      for (var _index = 0; _index < this.length; _index++) {
        this.right[_index] = this.right.junction[_index] * 0.999;
        this.left[_index] = this.left.junction[_index + 1] * 0.999;

        if (updateAmplitudes) {
          var sum = Math.abs(this.left[_index] + this.right[_index]);
          this.amplitude.max[_index] = sum > this.amplitude.max[_index] ? sum : this.amplitude.max[_index] * 0.999;
        }
      }

      return this.right[this.length - 1];
      ;
    }
  }, {
    key: "_processNose",
    value: function _processNose(parameterSamples, bufferInterpolation, updateAmplitudes) {
      this.nose.left.junction[this.nose.length] = this.nose.right[this.nose.length - 1] * this.lip.reflection;

      for (var index = 1; index < this.nose.length; index++) {
        var offset = this.nose.reflection[index] * (this.nose.left[index] + this.nose.right[index - 1]);
        this.nose.left.junction[index] = this.nose.left[index] + offset;
        this.nose.right.junction[index] = this.nose.right[index - 1] - offset;
      }

      for (var _index2 = 0; _index2 < this.nose.length; _index2++) {
        this.nose.left[_index2] = this.nose.left.junction[_index2 + 1] * this.nose.fade;
        this.nose.right[_index2] = this.nose.right.junction[_index2] * this.nose.fade;

        if (updateAmplitudes) {
          var sum = Math.abs(this.nose.left[_index2] + this.nose.right[_index2]);
          this.nose.amplitude.max[_index2] = sum > this.nose.amplitude.max[_index2] ? sum : this.nose.amplitude.max[_index2] * 0.999;
        }
      }

      return this.nose.right[this.nose.length - 1];
    } // UPDATE

  }, {
    key: "update",
    value: function update(seconds, constrictions) {
      this._updateTract();

      this._updateTransients(seconds);

      this.nose.diameter[0] = this.velum.target;
      this.nose.amplitude[0] = Math.pow(this.nose.diameter[0], 2);

      this._updateReflection();

      this._updateConstrictions(constrictions);
    }
  }, {
    key: "_updateDiameterRest",
    value: function _updateDiameterRest() {
      for (var index = this.blade.start; index < this.lip.start; index++) {
        var interpolation = (this.tongue.index - index) / (this.tip.start - this.blade.start);
        var angle = 1.1 * Math.PI * interpolation;
        var diameter = 2 + (this.tongue.diameter - 2) / 1.5;
        var curve = (1.5 - diameter + this.grid.offset) * Math.cos(angle);
        if (index == this.blade.start - 2 || index == this.lip.start - 1) curve *= 0.80;
        if (index == this.blade.start + 0 || index == this.lip.start - 2) curve *= 0.94;
        var value = 1.5 - curve;
        this.diameter.rest[index] = value;
      }
    }
  }, {
    key: "_updateConstrictions",
    value: function _updateConstrictions(constrictions) {
      var update = false;
      update = update || this.tongue.index !== this.previousConstrictions.tongue.index || this.tongue.diameter !== this.previousConstrictions.tongue.diameter;
      var maxIndex = Math.max(this.previousConstrictions.length, constrictions.length);

      for (var constrictionIndex = 0, A = constrictions[0], B = this.previousConstrictions[0]; !update && constrictionIndex < maxIndex; constrictionIndex++, A = constrictions[constrictionIndex], B = this.previousConstrictions[constrictionIndex]) {
        update = A !== undefined && B !== undefined ? A.index !== B.index || A.diameter !== B.diameter : !(A == undefined && B == undefined);
      }

      if (update) {
        this._updateDiameterRest();

        for (var index = 0; index < this.length; index++) {
          this.diameter[index] = this.diameter.rest[index];
        }

        this.velum.target = 0.01;

        for (var _index3 = -1; _index3 < constrictions.length; _index3++) {
          var constriction = constrictions[_index3] || this.tongue;
          if (constriction.index > this.nose.start && constriction.diameter < -this.nose.offset) this.velum.target = 0.4;

          if (constriction.index >= 2 && constriction.index < this.length && constriction.diameter > -(0.85 + this.nose.offset)) {
            var newTractDiameter = constriction.diameter;
            newTractDiameter -= 0.3;
            newTractDiameter = Math.max(0, newTractDiameter);

            if (newTractDiameter < 3) {
              var tractIndexRange = 2;
              if (constriction.index < 25) tractIndexRange = 10;else if (constriction.index >= this.tip.start) tractIndexRange = 5;else tractIndexRange = 10 - 5 * (constriction.index - 25) / (this.tip.start - 25);

              var _constrictionIndex = Math.round(constriction.index);

              var constrictionIndexRadius = Math.ceil(tractIndexRange) + 1;

              for (var tractIndex = _constrictionIndex - constrictionIndexRadius; tractIndex < _constrictionIndex + tractIndexRange + 1 && tractIndex >= 0 && tractIndex < this.length; tractIndex++) {
                var tractIndexOffset = Math.abs(tractIndex - constriction.index) - 0.5; // relpos

                var tractDiameterScalar; // shrink

                if (tractIndexOffset <= 0) tractDiameterScalar = 0;else if (tractIndexOffset > tractIndexRange) tractDiameterScalar = 1;else tractDiameterScalar = 0.5 * (1 - Math.cos(Math.PI * tractIndexOffset / tractIndexRange));
                var tractDiameterDifference = this.diameter[tractIndex] - newTractDiameter;

                if (tractDiameterDifference > 0) {
                  this.diameter[tractIndex] = newTractDiameter + tractDiameterDifference * tractDiameterScalar;
                }
              }
            }
          }
        }

        this.previousConstrictions = constrictions;
        this.previousConstrictions.tongue = {
          index: this.tongue.index,
          diameter: this.tongue.diameter
        };
      }
    }
  }, {
    key: "_updateTract",
    value: function _updateTract() {
      for (var index = 0; index < this.length; index++) {
        if (this.diameter[index] <= 0) {
          this.transients.obstruction["new"] = index;
        }
      }
    }
  }, {
    key: "_updateTransients",
    value: function _updateTransients(seconds) {
      if (this.nose.amplitude[0] < 0.05) {
        if (this.transients.obstruction.last > -1 && this.transients.obstruction["new"] == -1) this.transients.push(new processors_Transient(this.transients.obstruction["new"], seconds));
        this.transients.obstruction.last = this.transients.obstruction["new"];
      }
    }
  }, {
    key: "_updateReflection",
    value: function _updateReflection() {
      for (var index = 0; index < this.length; index++) {
        this.amplitude[index] = Math.pow(this.diameter[index], 2);

        if (index > 0) {
          this.reflection[index] = this.reflection["new"][index];
          this.reflection["new"][index] = this.amplitude[index] == 0 ? 0.999 : (this.amplitude[index - 1] - this.amplitude[index]) / (this.amplitude[index - 1] + this.amplitude[index]);
        }
      }

      var sum = this.amplitude[this.nose.start] + this.amplitude[this.nose.start + 1] + this.nose.amplitude[0];
      this.left.reflection.value = this.left.reflection["new"];
      this.left.reflection["new"] = (2 * this.amplitude[this.nose.start] - sum) / sum;
      this.right.reflection.value = this.right.reflection["new"];
      this.right.reflection["new"] = (2 * this.amplitude[this.nose.start + 1] - sum) / sum;
      this.nose.reflection.value = this.nose.reflection["new"];
      this.nose.reflection["new"] = (2 * this.nose.amplitude[0] - sum) / sum;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.right.fill(0);
      this.right.junction.fill(0);
      this.left.fill(0);
      this.left.junction.fill(0);
      this.nose.left.fill(0);
      this.nose.left.junction.fill(0);
      this.nose.right.fill(0);
      this.nose.right.junction.fill(0);
    }
  }]);

  return Tract;
}();

/* harmony default export */ var processors_Tract = (Tract_Tract);
// CONCATENATED MODULE: ./script/audio/nodes/pinkTrombone/processors/Processor.js
function Processor_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Processor_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Processor_createClass(Constructor, protoProps, staticProps) { if (protoProps) Processor_defineProperties(Constructor.prototype, protoProps); if (staticProps) Processor_defineProperties(Constructor, staticProps); return Constructor; }

/*
    TODO            
        add "precision" property to iterate this.tract.process
*/



var Processor_Processor =
/*#__PURE__*/
function () {
  function Processor() {
    Processor_classCallCheck(this, Processor);

    this.glottis = new processors_Glottis();
    this.tract = new processors_Tract();
  }

  Processor_createClass(Processor, [{
    key: "process",
    value: function process(parameterSamples, sampleIndex, bufferLength, seconds) {
      var _this$glottis, _this$tract;

      var outputSample = 0;

      var glottisSample = (_this$glottis = this.glottis).process.apply(_this$glottis, arguments);

      parameterSamples.glottis = glottisSample;
      outputSample += (_this$tract = this.tract).process.apply(_this$tract, arguments);
      sampleIndex += 0.5; // process twice - note the "...arguments" doesn't read this

      outputSample += this.tract.process(parameterSamples, sampleIndex, bufferLength, seconds);
      outputSample *= 0.125;
      return outputSample;
    }
  }, {
    key: "update",
    value: function update(seconds, constrictions) {
      this.glottis.update();
      this.tract.update(seconds, constrictions);
    }
  }]);

  return Processor;
}();

/* harmony default export */ var processors_Processor = (Processor_Processor);
// CONCATENATED MODULE: ./script/audio/nodes/pinkTrombone/AudioNode.js
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function AudioNode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function AudioNode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function AudioNode_createClass(Constructor, protoProps, staticProps) { if (protoProps) AudioNode_defineProperties(Constructor.prototype, protoProps); if (staticProps) AudioNode_defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) AudioNode_setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return AudioNode_construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return AudioNode_setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function AudioNode_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function AudioNode_construct(Parent, args, Class) { if (AudioNode_isNativeReflectConstruct()) { AudioNode_construct = Reflect.construct; } else { AudioNode_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) AudioNode_setPrototypeOf(instance, Class.prototype); return instance; }; } return AudioNode_construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function AudioNode_setPrototypeOf(o, p) { AudioNode_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AudioNode_setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/*
    TODO
        *
*/


window.AudioContext = window.AudioContext || window.webkitAudioContext; // CONSTRUCTOR HELPERS

function setupNode(audioNode) {
  audioNode._constrictions = [];

  var _loop = function _loop(constrictionIndex) {
    audioNode._constrictions[constrictionIndex] = {
      _index: constrictionIndex,
      index: null,
      diameter: null,
      _enable: function _enable() {
        return audioNode._enableConstriction(constrictionIndex);
      },
      _disable: function _disable() {
        return audioNode._disableConstriction(constrictionIndex);
      },
      _isEnabled: false
    };
  };

  for (var constrictionIndex = 0; constrictionIndex < processors_ParameterDescriptors.numberOfConstrictions; constrictionIndex++) {
    _loop(constrictionIndex);
  }

  audioNode.newConstriction = function (index, diameter) {
    return this._constrictions.find(function (constriction) {
      if (!constriction._isEnabled) {
        if (index !== undefined) constriction.index.value = index;
        if (diameter !== undefined) constriction.diameter.value = diameter;

        constriction._enable();

        return true;
      }
    });
  };

  audioNode.removeConstriction = function (constriction) {
    constriction._disable();
  };

  Object.defineProperty(audioNode, "constrictions", {
    get: function get() {
      return this._constrictions.filter(function (constriction) {
        return constriction._isEnabled;
      });
    }
  });
  audioNode._parameters = {};
  audioNode.tongue = audioNode._parameters.tongue = {
    index: null,
    diameter: null
  };
  audioNode.vibrato = audioNode._parameters.vibrato = {
    frequency: null,
    gain: null,
    wobble: null
  };
}

function assignAudioParam(audioNode, audioParam, paramName) {
  if (paramName.includes("constriction")) {
    var constrictionIndex = Number(paramName.match(/[0-9]+/g)[0]);
    var constriction = audioNode._constrictions[constrictionIndex];
    constriction[paramName.includes("index") ? "index" : "diameter"] = audioParam;
    audioNode.constrictions[constrictionIndex] = constriction;
  } else if (paramName.includes("vibrato")) {
    audioNode.vibrato[paramName.replace("vibrato", '').toLowerCase()] = audioParam;
  } else if (paramName.includes("tongue")) {
    audioNode.tongue[paramName.replace("tongue", '').toLowerCase()] = audioParam;
  } else {
    audioNode[paramName] = audioNode._parameters[paramName] = audioParam;
  }
}

if (window.AudioWorklet !== undefined) {
  var PinkTromboneNode =
  /*#__PURE__*/
  function (_AudioWorkletNode) {
    _inherits(PinkTromboneNode, _AudioWorkletNode);

    function PinkTromboneNode(audioContext) {
      var _this;

      AudioNode_classCallCheck(this, PinkTromboneNode);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(PinkTromboneNode).call(this, audioContext, "pink-trombone-worklet-processor"));
      setupNode(_assertThisInitialized(_this));

      _this.parameters.forEach(function (audioParam, paramName) {
        assignAudioParam(_assertThisInitialized(_this), audioParam, paramName);
      });

      _this.port.onmessage = function (event) {
        switch (event.data.name) {
          default:
            break;
        }
      };

      return _this;
    }

    AudioNode_createClass(PinkTromboneNode, [{
      key: "_postMessage",
      value: function _postMessage(eventData) {
        var _this2 = this;

        eventData.id = Math.random();
        return new Promise(function (resolve, reject) {
          var resolveCallback = function resolveCallback(event) {
            if (eventData.id == Number(event.data.id)) {
              _this2.port.removeEventListener("message", resolveCallback);

              resolve(event);
            }
          };

          _this2.port.addEventListener("message", resolveCallback);

          _this2.port.postMessage(eventData);
        });
      }
    }, {
      key: "_enableConstriction",
      value: function _enableConstriction(constrictionIndex) {
        var _this3 = this;

        return this._postMessage({
          name: "enableConstriction",
          constrictionIndex: constrictionIndex
        }).then(function () {
          _this3._constrictions[constrictionIndex]._isEnabled = true;
        });
      }
    }, {
      key: "_disableConstriction",
      value: function _disableConstriction(constrictionIndex) {
        var _this4 = this;

        return this._postMessage({
          name: "disableConstriction",
          constrictionIndex: constrictionIndex
        }).then(function () {
          _this4._constrictions[constrictionIndex]._isEnabled = false;
        });
      }
    }, {
      key: "getProcessor",
      value: function getProcessor() {
        return this._postMessage({
          name: "getProcessor"
        }).then(function (event) {
          return JSON.parse(event.data.processor);
        });
      }
    }]);

    return PinkTromboneNode;
  }(_wrapNativeSuper(AudioWorkletNode));

  window.AudioContext.prototype.createPinkTromboneNode = function () {
    return AudioNode_construct(PinkTromboneNode, [this].concat(Array.prototype.slice.call(arguments)));
  };
} else {
  window.AudioContext.prototype.createPinkTromboneNode = function () {
    var _this5 = this;

    var pinkTromboneNode = this.createScriptProcessor(Math.pow(2, 11), processors_ParameterDescriptors.length, 1);
    pinkTromboneNode.processor = new processors_Processor();
    setupNode(pinkTromboneNode);
    pinkTromboneNode.channelMerger = this.createChannelMerger(processors_ParameterDescriptors.length);
    pinkTromboneNode.channelMerger.channels = [];
    pinkTromboneNode.channelMerger.connect(pinkTromboneNode);
    processors_ParameterDescriptors.forEach(function (parameterDescriptor, index) {
      var constantSource = _this5.createConstantSource();

      constantSource.start();
      var audioParam = constantSource.offset;
      audioParam.automationRate = parameterDescriptor.automationRate || "a-rate";
      audioParam.value = parameterDescriptor.defaultValue || 0;
      constantSource.connect(pinkTromboneNode.channelMerger, 0, index);
      pinkTromboneNode.channelMerger.channels[index] = parameterDescriptor.name;
      assignAudioParam(pinkTromboneNode, audioParam, parameterDescriptor.name);
    });

    pinkTromboneNode._getParameterChannels = function (inputBuffer) {
      var parameterChannels = {};

      for (var channelIndex = 0; channelIndex < inputBuffer.numberOfChannels; channelIndex++) {
        parameterChannels[this.channelMerger.channels[channelIndex]] = inputBuffer.getChannelData(channelIndex);
      }

      return parameterChannels;
    };

    pinkTromboneNode._getParameterSamples = function (parameterChannels, sampleIndex) {
      var parameterSamples = {};
      var parameterNames = Object.keys(parameterChannels);

      for (var channelIndex = 0; channelIndex < parameterNames.length; channelIndex++) {
        var parameterName = parameterNames[channelIndex];
        if (!parameterName.includes("constriction")) parameterSamples[parameterName] = parameterChannels[parameterName][sampleIndex];
      }

      return parameterSamples;
    };

    pinkTromboneNode._getConstrictions = function (parameterChannels) {
      var constrictions = [];

      for (var constrictionIndex = 0; constrictionIndex < this._constrictions.length; constrictionIndex++) {
        var _constriction = this._constrictions[constrictionIndex];

        if (_constriction._isEnabled) {
          var constriction = {
            index: parameterChannels["constriction" + constrictionIndex + "index"][0],
            diameter: parameterChannels["constriction" + constrictionIndex + "diameter"][0]
          };
          constrictions[constrictionIndex] = constriction;
        }
      }

      return constrictions;
    };

    pinkTromboneNode.onaudioprocess = function (event) {
      var outputChannel = event.outputBuffer.getChannelData(0);

      var parameterChannels = this._getParameterChannels(event.inputBuffer);

      var constrictions = this._getConstrictions(parameterChannels);

      for (var sampleIndex = 0; sampleIndex < outputChannel.length; sampleIndex++) {
        var parameterSamples = this._getParameterSamples(parameterChannels, sampleIndex);

        var bufferLength = outputChannel.length;
        var seconds = event.playbackTime + sampleIndex / event.inputBuffer.sampleRate;
        outputChannel[sampleIndex] = this.processor.process(parameterSamples, sampleIndex, bufferLength, seconds, constrictions);
      }

      this.processor.update(event.playbackTime + outputChannel.length / event.inputBuffer.sampleRate, constrictions);
    };

    pinkTromboneNode._enableConstriction = function (constrictionIndex) {
      this._constrictions[constrictionIndex]._isEnabled = true;
    };

    pinkTromboneNode._disableConstriction = function (constrictionIndex) {
      this._constrictions[constrictionIndex]._isEnabled = false;
    };

    pinkTromboneNode.getProcessor = function () {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        resolve(_this6.processor);
      });
    };

    return pinkTromboneNode;
  };
}


// CONCATENATED MODULE: ./script/PinkTrombone.js
function PinkTrombone_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function PinkTrombone_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function PinkTrombone_createClass(Constructor, protoProps, staticProps) { if (protoProps) PinkTrombone_defineProperties(Constructor.prototype, protoProps); if (staticProps) PinkTrombone_defineProperties(Constructor, staticProps); return Constructor; }

/*
    TODO
        start/stop for the pinkTromboneNode
*/



window.AudioContext = window.AudioContext || window.webkitAudioContext;

var PinkTrombone =
/*#__PURE__*/
function () {
  PinkTrombone_createClass(PinkTrombone, [{
    key: "addModules",
    value: function addModules(audioContext) {
      if (audioContext.audioWorklet !== undefined) {
        //return audioContext.audioWorklet.addModule("./script/audio/nodes/pinkTrombone/processors/WorkletProcessor.js")
        return audioContext.audioWorklet.addModule("./pink-trombone-worklet-processor.min.js");
      } else {
        return new Promise(function (resolve, reject) {
          resolve();
        });
      }
    }
  }]);

  function PinkTrombone(audioContext) {
    var _this = this;

    PinkTrombone_classCallCheck(this, PinkTrombone);

    this.loadPromise = this.addModules(audioContext).then(function () {
      _this.audioContext = audioContext;

      _this.setupAudioGraph();

      return _this.audioContext;
    });
  }

  PinkTrombone_createClass(PinkTrombone, [{
    key: "setupAudioGraph",
    value: function setupAudioGraph() {
      this._noise = this.audioContext.createNoise();
      this._aspirateFilter = this.audioContext.createBiquadFilter();
      this._aspirateFilter.type = "bandpass";
      this._aspirateFilter.frequency.value = 500;
      this._aspirateFilter.Q.value = 0.5;
      this._fricativeFilter = this.audioContext.createBiquadFilter();
      this._fricativeFilter.type = "bandpass";
      this._fricativeFilter.frequency.value = 1000;
      this._fricativeFilter.Q.value = 0.5;
      this._pinkTromboneNode = this.audioContext.createPinkTromboneNode();

      this._noise.connect(this._aspirateFilter);

      this._aspirateFilter.connect(this._pinkTromboneNode.noise);

      this._noise.connect(this._fricativeFilter);

      this._fricativeFilter.connect(this._pinkTromboneNode.noise);

      this._gain = this.audioContext.createGain();
      this._gain.gain.value = 0;

      this._pinkTromboneNode.connect(this._gain);
    }
  }, {
    key: "connect",
    value: function connect() {
      var _this$_gain;

      return (_this$_gain = this._gain).connect.apply(_this$_gain, arguments);
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      var _this$_gain2;

      return (_this$_gain2 = this._gain).disconnect.apply(_this$_gain2, arguments);
    }
  }, {
    key: "start",
    value: function start() {
      this._gain.gain.value = 1;
    }
  }, {
    key: "stop",
    value: function stop() {
      this._gain.gain.value = 0;
    }
  }, {
    key: "newConstriction",
    value: function newConstriction() {
      var _this$_pinkTromboneNo;

      return (_this$_pinkTromboneNo = this._pinkTromboneNode).newConstriction.apply(_this$_pinkTromboneNo, arguments);
    }
  }, {
    key: "removeConstriction",
    value: function removeConstriction(constriction) {
      this._pinkTromboneNode.removeConstriction(constriction);
    }
  }, {
    key: "getProcessor",
    value: function getProcessor() {
      return this._pinkTromboneNode.getProcessor();
    }
  }, {
    key: "parameters",
    get: function get() {
      return this._pinkTromboneNode._parameters;
    }
  }, {
    key: "constrictions",
    get: function get() {
      return this._pinkTromboneNode.constrictions;
    }
  }]);

  return PinkTrombone;
}();

window.AudioContext.prototype.createPinkTrombone = function () {
  return new PinkTrombone(this);
};

/* harmony default export */ var script_PinkTrombone = (PinkTrombone);
// CONCATENATED MODULE: ./script/graphics/TractUI.js
function TractUI_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TractUI_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function TractUI_createClass(Constructor, protoProps, staticProps) { if (protoProps) TractUI_defineProperties(Constructor.prototype, protoProps); if (staticProps) TractUI_defineProperties(Constructor, staticProps); return Constructor; }

/*
    TODO
        throttle value setter
        draw background stuff
*/
var TractUI =
/*#__PURE__*/
function () {
  function TractUI() {
    var _this = this;

    TractUI_classCallCheck(this, TractUI);

    this._container = document.createElement("div");
    this._container.style.margin = 0;
    this._container.style.padding = 0;
    this._canvases = {};
    this._contexts = {};
    ["tract", "background"].forEach(function (id, index) {
      var canvas = document.createElement("canvas");
      canvas.id = id;
      canvas.style.position = "absolute";
      canvas.height = 500;
      canvas.width = 600;
      canvas.style.backgroundColor = "transparent";
      canvas.style.margin = 0;
      canvas.style.padding = 0;
      canvas.style.zIndex = 1 - index;
      _this._canvases[id] = canvas;
      _this._contexts[id] = canvas.getContext("2d");

      _this._container.appendChild(canvas);
    });
    this._canvas = this._canvases.tract;
    this._context = this._contexts.tract;
    this._tract = {
      origin: {
        x: 340,
        y: 460
      },
      radius: 298,
      scale: 60,
      scalar: 1,
      angle: {
        scale: 0.64,
        offset: -0.25
      }
    };
    this._processor = null;
    this._parameters = {};
    this._touchConstrictionIndices = []; // AnimationFrame

    this._container.addEventListener("animationFrame", function (event) {
      _this._container.dispatchEvent(new CustomEvent("getProcessor", {
        bubbles: true
      }));

      _this._container.dispatchEvent(new CustomEvent("getParameter", {
        bubbles: true,
        detail: {
          parameterName: "intensity"
        }
      }));
    });

    this._container.addEventListener("didGetProcessor", function (event) {
      _this._processor = event.detail.processor;

      _this._resize();

      _this._drawTract();
    });

    this._container.addEventListener("didGetParameter", function (event) {
      var parameterName = event.detail.parameterName;
      var value = event.detail.value;
      _this._parameters[parameterName] = value;
    }); // RequestAnimationFrame after being attached to the DOM


    var mutationObserver = new MutationObserver(function (mutationsList, observer) {
      if (document.contains(_this._container)) {
        _this._container.dispatchEvent(new CustomEvent("requestAnimationFrame", {
          bubbles: true
        }));

        observer.disconnect();
      }
    });
    mutationObserver.observe(document.body, {
      subtree: true,
      childList: true
    }); // Mouse EventListeners

    this._canvases.tract.addEventListener("mousedown", function (event) {
      _this._startEvent(event);
    });

    this._canvases.tract.addEventListener("mousemove", function (event) {
      _this._moveEvent(event);
    });

    this._canvases.tract.addEventListener("mouseup", function (event) {
      _this._endEvent(event);
    }); // Touch EventListeners


    this._canvases.tract.addEventListener("touchstart", function (event) {
      event.preventDefault();
      Array.from(event.changedTouches).forEach(function (touch) {
        return _this._startEvent(touch);
      });
    });

    this._canvases.tract.addEventListener("touchmove", function (event) {
      event.preventDefault();
      Array.from(event.changedTouches).forEach(function (touch) {
        return _this._moveEvent(touch);
      });
    });

    this._canvases.tract.addEventListener("touchend", function (event) {
      event.preventDefault();
      Array.from(event.changedTouches).forEach(function (touch) {
        return _this._endEvent(touch);
      });
    });

    this._canvases.tract.addEventListener("touchcancel", function (event) {
      event.preventDefault();
      Array.from(event.changedTouches).forEach(function (touch) {
        return _this._endEvent(touch);
      });
    }); // Constriction EventLiteners


    this._canvases.tract.addEventListener("didNewConstriction", function (event) {
      _this._touchConstrictionIndices[event.detail.touchIdentifier] = event.detail.constrictionIndex;
    });

    this._canvases.tract.addEventListener("didRemoveConstriction", function (event) {
      _this._touchConstrictionIndices[event.detail.touchIdentifier] = undefined;
    });
  }

  TractUI_createClass(TractUI, [{
    key: "_resize",
    value: function _resize() {
      this._tract.scalar = this._canvases.tract.width / this._canvases.tract.offsetWidth;

      this._resizeCanvases();
    }
  }, {
    key: "_resizeCanvases",
    value: function _resizeCanvases() {
      for (var id in this._canvases) {
        //this._canvases[id].style.width = this._container.offsetWidth;
        this._canvases[id].style.height = this._container.offsetHeight;
      }
    }
  }, {
    key: "_drawTract",
    value: function _drawTract() {
      if (this._isDrawing) return;
      this._isDrawing = true;
      this._context = this._contexts.tract;

      this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);

      this._context.lineCap = this._context.lineJoin = "round";

      this._drawTongueControl();

      this._context.beginPath();

      this._context.lineWidth = 2;
      this._context.strokeStyle = this._context.fillStyle = "pink";

      this._moveTo(1, 0);

      for (var index = 1; index < this._processor.tract.length; index++) {
        this._lineTo(index, this._processor.tract.diameter[index]);
      }

      for (var _index2 = this._processor.tract.length - 1; _index2 >= 2; _index2--) {
        this._lineTo(_index2, 0);
      }

      this._context.closePath();

      this._context.stroke();

      this._context.fill(); // NOSE


      var velum = this._processor.tract.nose.diameter[0];
      var velumAngle = velum * 4;

      this._context.beginPath();

      this._context.lineWidth = 2;
      this._context.strokeStyle = this._context.fillStyle = "pink";

      this._moveTo(this._processor.tract.nose.start, -this._processor.tract.nose.offset);

      for (var _index3 = 1; _index3 < this._processor.tract.nose.length; _index3++) {
        this._lineTo(_index3 + this._processor.tract.nose.start, -this._processor.tract.nose.offset - this._processor.tract.nose.diameter[_index3] * 0.9);
      }

      for (var _index4 = this._processor.tract.nose.length - 1; _index4 >= 1; _index4--) {
        this._lineTo(_index4 + this._processor.tract.nose.start, -this._processor.tract.nose.offset);
      }

      this._context.closePath();

      this._context.fill();

      this._context.beginPath();

      this._context.lineWidth = 2;
      this._context.strokeStyle = this._context.fillStyle = "pink";

      this._moveTo(this._processor.tract.nose.start - 2, 0);

      this._lineTo(this._processor.tract.nose.start, -this._processor.tract.nose.offset);

      this._lineTo(this._processor.tract.nose.start + velumAngle, -this._processor.tract.nose.offset);

      this._lineTo(this._processor.tract.nose.start + velumAngle - 2, 0);

      this._context.closePath();

      this._context.stroke();

      this._context.fill();

      this._context.fillStyle = "white";
      this._context.font = "20px Arial";
      this._context.textAlign = "center";
      this._context.globalAlpha = 1;

      this._drawText(this._processor.tract.length * 0.10, 0.425, "throat", false);

      this._drawText(this._processor.tract.length * 0.71, -1.800, "nasal", false);

      this._drawText(this._processor.tract.length * 0.71, -1.300, "cavity", false);

      this._context.font = "22px Arial";

      this._drawText(this._processor.tract.length * 0.6, 0.9, "oral", false);

      this._drawText(this._processor.tract.length * 0.7, 0.9, "cavity", false);

      this._drawAmplitudes();

      this._context.beginPath();

      this._context.lineWidth = 5;
      this._context.strokeStyle = "#C070C6";
      this._context.lineJoin = this._context.lineCap = "round";

      this._moveTo(1, this._processor.tract.diameter[0]);

      for (var _index5 = 2; _index5 < this._processor.tract.length; _index5++) {
        this._lineTo(_index5, this._processor.tract.diameter[_index5]);
      }

      this._moveTo(1, 0);

      for (var _index6 = 2; _index6 <= this._processor.tract.nose.start - 2; _index6++) {
        this._lineTo(_index6, 0);
      }

      this._moveTo(this._processor.tract.nose.start + velumAngle - 2, 0);

      for (var _index7 = this._processor.tract.nose.start + Math.ceil(velumAngle) - 2; _index7 < this._processor.tract.length; _index7++) {
        this._lineTo(_index7, 0);
      }

      this._context.stroke();

      this._context.beginPath();

      this._context.lineWidth = 5;
      this._context.strokeStyle = "#C070C6";
      this._context.lineJoin = "round";

      this._moveTo(this._processor.tract.nose.start, -this._processor.tract.nose.offset);

      for (var _index8 = 1; _index8 < this._processor.tract.nose.length; _index8++) {
        this._lineTo(_index8 + this._processor.tract.nose.start, -this._processor.tract.nose.offset - this._processor.tract.nose.diameter[_index8] * 0.9);
      }

      this._moveTo(this._processor.tract.nose.start + velumAngle, -this._processor.tract.nose.offset);

      for (var _index9 = Math.ceil(velumAngle); _index9 < this._processor.tract.nose.length; _index9++) {
        this._lineTo(_index9 + this._processor.tract.nose.start, -this._processor.tract.nose.offset);
      }

      this._context.stroke();

      this._context.globalAlpha = velum * 5;

      this._context.beginPath();

      this._moveTo(this._processor.tract.nose.start - 2, 0);

      this._lineTo(this._processor.tract.nose.start, -this._processor.tract.nose.offset);

      this._lineTo(this._processor.tract.nose.start + velumAngle, -this._processor.tract.nose.offset);

      this._lineTo(this._processor.tract.nose.start + velumAngle - 2, 0);

      this._context.stroke();

      this._context.fillStyle = "orchid";
      this._context.font = "20px Arial";
      this._context.textAlign = "center";
      this._context.globalAlpha = 0.7;

      this._drawText(this._processor.tract.length * 0.95, 0.8 + 0.8 * this._processor.tract.diameter[this._processor.tract.length - 1], " lip", false);

      this._context.globalAlpha = 1;
      this._context.fillStyle = "black";
      this._context.textAlign = "left";

      this._drawPositions();

      this._isDrawing = false;
    }
  }, {
    key: "_drawCircle",
    value: function _drawCircle(index, diameter, arcRadius) {
      var angle = this._getAngle(index);

      var radius = this._getRadius(index, diameter);

      this._context.beginPath();

      this._context.arc(this._getX(angle, radius), this._getY(angle, radius), arcRadius, 0, 2 * Math.PI);

      this._context.fill();
    }
  }, {
    key: "_drawTongueControl",
    value: function _drawTongueControl() {
      var _this2 = this;

      this._context.lineCap = this._context.lineJoin = "round";
      this._context.strokeStyle = this._context.fillStyle = "#FFEEF5"; // palePink

      this._context.globalAlpha = 1.0;

      this._context.beginPath();

      this._context.lineWidth = 45;

      this._moveTo(this._processor.tract.tongue.range.index.minValue, this._processor.tract.tongue.diameter.minValue); // diameter/2?


      for (var index = this._processor.tract.tongue.range.index.minValue + 1; index <= this._processor.tract.tongue.range.maxValue; index++) {
        this._lineTo(index, this._processor.tract.tongue.range.diameter.minValue);
      }

      this._lineTo(this._processor.tract.tongue.range.index.center, this._processor.tract.tongue.range.diameter.maxValue);

      this._context.closePath();

      this._context.stroke();

      this._context.fill();

      this._context.fillStyle = "orchid";
      this._context.globalAlpha = 0.3;
      [0, -4.25, -8.5, 4.25, 8.5, -6.1, 6.1, 0, 0].forEach(function (indexOffset, _index) {
        var diameter = _index < 5 ? _this2._processor.tract.tongue.range.diameter.minValue : _index < 8 ? _this2._processor.tract.tongue.range.diameter.center : _this2._processor.tract.tongue.range.diameter.maxValue;

        _this2._drawCircle(_this2._processor.tract.tongue.range.index.center + indexOffset, diameter, 3);
      });

      var tongueAngle = this._getAngle(this._processor.tract.tongue.index);

      var tongueRadius = this._getRadius(this._processor.tract.tongue.index, this._processor.tract.tongue.diameter);

      this._context.lineWidth = 4;
      this._context.strokeStyle = "orchid";
      this._context.globalAlpha = 0.7;

      this._context.beginPath();

      this._context.arc(this._getX(tongueAngle, tongueRadius), this._getY(tongueAngle, tongueRadius), 18, 0, 2 * Math.PI);

      this._context.stroke();

      this._context.globalAlpha = 0.15;

      this._context.fill();

      this._context.globalAlpha = 1;
      this._context.fillStyle = "orchid";
    }
  }, {
    key: "_drawAmplitudes",
    value: function _drawAmplitudes() {
      this._context.strokeStyle = "orchid";
      this._context.lineCap = "butt";
      this._context.globalAlpha = 0.3;

      for (var index = 2; index < this._processor.tract.length - 1; index++) {
        this._context.beginPath();

        this._context.lineWidth = Math.sqrt(this._processor.tract.amplitude.max[index]) * 3;

        this._moveTo(index, 0);

        this._lineTo(index, this._processor.tract.diameter[index]);

        this._context.stroke();
      }

      for (var _index10 = 1; _index10 < this._processor.tract.nose.length - 1; _index10++) {
        this._context.beginPath();

        this._context.lineWidth = Math.sqrt(this._processor.tract.nose.amplitude.max[_index10]) * 3;

        this._moveTo(this._processor.tract.nose.start + _index10, -this._processor.tract.nose.offset);

        this._lineTo(this._processor.tract.nose.start + _index10, -this._processor.tract.nose.offset - this._processor.tract.nose.diameter[_index10] * 0.9);

        this._context.stroke();
      }

      this._context.globalAlpha = 1;
    }
  }, {
    key: "_drawPositions",
    value: function _drawPositions() {
      var _this3 = this;

      this._context.fillStyle = "orchid";
      this._context.font = "24px Arial";
      this._context.textAlign = "center";
      this._context.globalAlpha = 0.6;
      [[15, 0.60, ''], // pat
      [13, 0.27, 'a'], // part
      [12, 0, ''], // pot
      [17.7, 0.05, '()'], // port (rounded)
      [27, 0.65, ''], // pit
      [27.4, 0.21, 'i'], // peat
      [20, 1.00, 'e'], // pet
      [18.1, 0.37, ''], // putt
      [23, 0.1, '(u)'], // poot (rounded)
      [21, 0.6, '']].forEach(function (position) {
        var angle = position[0];
        var radius = position[1] * 1.5 + 2;
        var phoneme = position[2];

        _this3._drawText(angle, radius, phoneme, false);
      });
      this._context.globalAlpha = 0.8;
      var approximants = 1.1;

      this._drawText(38, approximants, 'l', false);

      this._drawText(41, approximants, 'w', false);

      this._drawText(4.5, 0.37, 'h', false); // setting up phoneme stuff


      var phonemes = this._parameters.intensity > 0 ? ['', 'z', 'v', 'g', 'd', 'b'] : ['', 's', 'f', 'k', 't', 'p'];
      phonemes.push('', 'n', 'm');
      var fricatives = 0.3;
      var stops = -0.4;
      var nasals = -1.1;
      [31.5, 36, 41, 22, 36, 41, 22, 36, 41].forEach(function (angle, _index) {
        var radius = _index < 4 ? fricatives : _index < 6 ? stops : nasals;

        _this3._drawText(angle, radius, phonemes[_index], false);
      });
    }
  }, {
    key: "_drawText",
    value: function _drawText(index, diameter, text) {
      var isStraight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      var angle = this._getAngle(index);

      var radius = this._getRadius(index, diameter);

      this._context.save();

      this._context.translate(this._getX(angle, radius), this._getY(angle, radius) + 2);

      if (!isStraight) this._context.rotate(angle - Math.PI / 2);

      this._context.fillText(text, 0, 0);

      this._context.restore();
    }
  }, {
    key: "_moveTo",
    value: function _moveTo(index, diameter) {
      this.__to(index, diameter, true);
    }
  }, {
    key: "_lineTo",
    value: function _lineTo(index, diameter) {
      this.__to(index, diameter, false);
    }
  }, {
    key: "__to",
    value: function __to(index, diameter) {
      var moveTo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var wobble = this._getWobble(index);

      var angle = this._getAngle(index, diameter) + wobble;
      var radius = this._getRadius(index, diameter) + 100 * wobble;

      var x = this._getX(angle, radius);

      var y = this._getY(angle, radius);

      if (moveTo) this._context.moveTo(x, y);else this._context.lineTo(x, y);
    }
  }, {
    key: "_getX",
    value: function _getX(angle, radius) {
      return this._tract.origin.x - radius * Math.cos(angle);
    }
  }, {
    key: "_getY",
    value: function _getY(angle, radius) {
      return this._tract.origin.y - radius * Math.sin(angle);
    }
  }, {
    key: "_getAngle",
    value: function _getAngle(index) {
      var angle = this._tract.angle.offset + index * this._tract.angle.scale * Math.PI / (this._processor.tract.lip.start - 1);
      return angle;
    }
  }, {
    key: "_getWobble",
    value: function _getWobble(index) {
      var wobble = this._processor.tract.amplitude.max[this._processor.tract.length - 1] + this._processor.tract.nose.amplitude.max[this._processor.tract.nose.length - 1];
      wobble *= 0.03 * Math.sin(2 * index - 50 * (Date.now() / 1000)) * index / this._processor.tract.length;
      return wobble;
    }
  }, {
    key: "_getRadius",
    value: function _getRadius(index, diameter) {
      var radius = this._tract.radius - this._tract.scale * diameter;
      return radius;
    }
  }, {
    key: "_getIndex",
    value: function _getIndex(x, y) {
      var angle = Math.atan2(y, x);

      while (angle > 0) {
        angle -= 2 * Math.PI;
      }

      var index = (Math.PI + angle - this._tract.angle.offset) * (this._processor.tract.lip.start - 1) / (this._tract.angle.scale * Math.PI);
      return index;
    }
  }, {
    key: "_getDiameter",
    value: function _getDiameter(x, y) {
      var diameter = (this._tract.radius - Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))) / this._tract.scale;

      return diameter;
    }
  }, {
    key: "_isNearTongue",
    value: function _isNearTongue(index, diameter) {
      var isTongue = true;
      isTongue = isTongue && this._processor.tract.tongue.range.index.minValue - 4 <= index && index <= this._processor.tract.tongue.range.index.maxValue + 4;
      isTongue = isTongue && this._processor.tract.tongue.range.diameter.minValue - 0.5 <= diameter && diameter <= this._processor.tract.tongue.range.diameter.maxValue + 0.5;
      return isTongue;
    }
  }, {
    key: "_getEventX",
    value: function _getEventX(event) {
      var x = (event.pageX - event.target.offsetLeft) * this._tract.scalar - this._tract.origin.x;
      return x;
    }
  }, {
    key: "_getEventY",
    value: function _getEventY(event) {
      var y = (event.pageY - event.target.offsetTop) * this._tract.scalar - this._tract.origin.y;
      return y;
    }
  }, {
    key: "_getEventPosition",
    value: function _getEventPosition(event) {
      var x = this._getEventX(event);

      var y = this._getEventY(event);

      return {
        index: this._getIndex(x, y),
        diameter: this._getDiameter(x, y)
      };
    }
  }, {
    key: "_setTongue",
    value: function _setTongue(event, position) {
      Object.keys(position).forEach(function (parameterNameSuffix) {
        event.target.dispatchEvent(new CustomEvent("setParameter", {
          bubbles: true,
          detail: {
            parameterName: "tongue." + parameterNameSuffix,
            newValue: position[parameterNameSuffix]
          }
        }));
      });
    }
  }, {
    key: "_startEvent",
    value: function _startEvent(event) {
      var touchIdentifier = event instanceof Touch ? event.identifier : -1;

      if (this._touchConstrictionIndices[touchIdentifier] == undefined) {
        var position = this._getEventPosition(event);

        var isNearTongue = this._isNearTongue(position.index, position.diameter);

        if (isNearTongue) {
          this._touchConstrictionIndices[touchIdentifier] = -1;

          this._setTongue(event, position);
        } else {
          event.target.dispatchEvent(new CustomEvent("newConstriction", {
            bubbles: true,
            detail: {
              touchIdentifier: touchIdentifier,
              index: position.index,
              diameter: position.diameter
            }
          }));
        }
      }
    }
  }, {
    key: "_moveEvent",
    value: function _moveEvent(event) {
      var touchIdentifier = event instanceof Touch ? event.identifier : -1;

      if (this._touchConstrictionIndices[touchIdentifier] !== undefined) {
        var position = this._getEventPosition(event);

        var constrictionIndex = this._touchConstrictionIndices[touchIdentifier];
        var isTongue = constrictionIndex == -1;

        if (isTongue) {
          this._setTongue(event, position);
        } else {
          event.target.dispatchEvent(new CustomEvent("setConstriction", {
            bubbles: true,
            detail: {
              constrictionIndex: constrictionIndex,
              index: position.index,
              diameter: position.diameter
            }
          }));
        }
      }
    }
  }, {
    key: "_endEvent",
    value: function _endEvent(event) {
      var touchIdentifier = event instanceof Touch ? event.identifier : -1;

      if (this._touchConstrictionIndices[touchIdentifier] !== undefined) {
        var constrictionIndex = this._touchConstrictionIndices[touchIdentifier];
        var isTongue = constrictionIndex == -1;

        if (isTongue) {// do nothing
        } else {
          event.target.dispatchEvent(new CustomEvent("removeConstriction", {
            bubbles: true,
            detail: {
              constrictionIndex: constrictionIndex,
              touchIdentifier: touchIdentifier
            }
          }));
        }

        this._touchConstrictionIndices[touchIdentifier] = undefined;
      }
    }
  }, {
    key: "node",
    get: function get() {
      return this._container;
    }
  }, {
    key: "width",
    get: function get() {
      return this._container.offsetWidth;
    }
  }, {
    key: "height",
    get: function get() {
      return this._container.offsetHeight;
    }
  }]);

  return TractUI;
}();

/* harmony default export */ var graphics_TractUI = (TractUI);
// CONCATENATED MODULE: ./script/graphics/GlottisUI.js
function GlottisUI_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function GlottisUI_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function GlottisUI_createClass(Constructor, protoProps, staticProps) { if (protoProps) GlottisUI_defineProperties(Constructor.prototype, protoProps); if (staticProps) GlottisUI_defineProperties(Constructor, staticProps); return Constructor; }

/*
    TODO        
        throttle value setter
        set actual frequency range
*/
Math.clamp = function (value) {
  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return value < min ? min : value < max ? value : max;
};

var GlottisUI =
/*#__PURE__*/
function () {
  function GlottisUI() {
    var _this = this;

    GlottisUI_classCallCheck(this, GlottisUI);

    this._frequency = {
      min: 20,
      max: 1000,

      get range() {
        return this.max - this.min;
      },

      interpolate: function interpolate(interpolation) {
        return this.min + this.range * interpolation;
      }
    };
    this._isActive = false;
    this._alwaysVoice = true;
    this._container = document.createElement("div");
    this._container.style.border = "solid red 1px";
    this._container.style.backgroundColor = "pink";
    this._container.style.borderRadius = "20px";
    this._slider = document.createElement("div");
    this._slider.style.position = "relative";
    this._slider.style.flex = 0;
    this._slider.style.width = "20px";
    this._slider.style.height = "20px";
    this._slider.style.borderRadius = "20px";
    this._slider.style.border = "solid red 5px";
    this._slider.style.top = "50%";
    this._slider.style.left = "50%";

    this._container.appendChild(this._slider); // EventListeners for setting the Parameters


    this._container.addEventListener("mousedown", function (event) {
      _this._isActive = true;

      _this._eventCallback(event);

      if (!_this._alwaysVoice) _this._container.dispatchEvent(new CustomEvent("setParameter", {
        bubbles: true,
        detail: {
          parameterName: "intensity",
          newValue: 1 // type : "linear"
          // time : ?

        }
      }));
    });

    this._container.addEventListener("mousemove", function (event) {
      _this._eventCallback(event);
    });

    this._container.addEventListener("mouseup", function (event) {
      _this._isActive = false;
      if (_this._alwaysVoice == false) _this._container.dispatchEvent(new CustomEvent("setParameter", {
        bubbles: true,
        detail: {
          parameterName: "intensity",
          newValue: 0 // type : "linear"
          // time : ?

        }
      }));
    });

    this._container.addEventListener("touchstart", function (event) {
      event.preventDefault();

      if (!_this._isActive) {
        _this._isActive = true;
        var touch = event.changedTouches[0];
        _this._touchIdentifier = touch.identifier;

        _this._eventCallback(touch);

        if (!_this._alwaysVoice) _this._container.dispatchEvent(new CustomEvent("setParameter", {
          bubbles: true,
          detail: {
            parameterName: "intensity",
            newValue: 1 // type : "linear"
            // time : ?

          }
        }));
      }
    });

    this._container.addEventListener("touchmove", function (event) {
      event.preventDefault();
      var touch = Array.from(event.changedTouches).find(function (touch) {
        return touch.identifier == _this._touchIdentifier;
      });
      if (touch !== undefined) _this._eventCallback(touch);
    });

    this._container.addEventListener("touchend", function (event) {
      event.preventDefault();

      if (_this._isActive && Array.from(event.changedTouches).some(function (touch) {
        return touch.identifier == _this._touchIdentifier;
      })) {
        _this._isActive = false;
        _this._touchIdentifier = -1;
      }

      if (!_this._alwaysVoice) _this._container.dispatchEvent(new CustomEvent("setParameter", {
        bubbles: true,
        detail: {
          parameterName: "intensity",
          newValue: 0 // type : "linear"
          // time : ?

        }
      }));
    });

    this._container.addEventListener("message", function (event) {
      if (event.detail.type == "toggleButton") {
        if (event.detail.parameterName == "voice") {
          _this._alwaysVoice = event.detail.newValue == "true";
        }
      }
    }); // Observe AnimationFrame


    var mutationObserver = new MutationObserver(function (mutationsList, observer) {
      if (document.contains(_this._container)) {
        var customEvent = new CustomEvent("requestAnimationFrame", {
          bubbles: true
        });

        _this._container.dispatchEvent(customEvent);

        observer.disconnect();
      }
    });
    mutationObserver.observe(document.body, {
      subtree: true,
      childList: true
    }); // AnimationFrame EventListener

    this._container.addEventListener("animationFrame", function (event) {
      ["frequency", "tenseness"].forEach(function (parameterName) {
        var customEvent = new CustomEvent("getParameter", {
          bubbles: true,
          detail: {
            parameterName: parameterName,
            render: true
          }
        });
        event.target.dispatchEvent(customEvent);
      });
    }); // EventListeners for Getting Parameters


    this._container.addEventListener("didGetParameter", function (event) {
      if (event.detail.render == true) {
        var parameterName = event.detail.parameterName;
        var value = event.detail.value;

        if (["frequency", "tenseness"].includes(parameterName)) {
          var interpolation;

          if (parameterName == "frequency") {
            interpolation = Math.clamp((value - _this._frequency.min) / _this._frequency.range);
            _this._slider.style.left = interpolation * _this._container.offsetWidth - _this._slider.offsetWidth / 2;
          } else {
            interpolation = 1 - Math.acos(1 - value) / (Math.PI * 0.5);
            _this._slider.style.top = interpolation * _this._container.offsetHeight - _this._slider.offsetHeight / 2;
          }
        }
      }
    });
  }

  GlottisUI_createClass(GlottisUI, [{
    key: "_eventCallback",
    value: function _eventCallback(event) {
      var _this2 = this;

      if (this._isActive) {
        var interpolation = {
          vertical: Math.clamp((event.pageY - this._container.offsetTop) / this._container.offsetHeight, 0, 0.99),
          horizontal: Math.clamp((event.pageX - this._container.offsetLeft) / this._container.offsetWidth, 0, 0.99)
        };

        var frequency = this._frequency.interpolate(interpolation.horizontal);

        var tenseness = 1 - Math.cos((1 - interpolation.vertical) * Math.PI * 0.5);
        var loudness = Math.pow(tenseness, 0.25);
        var parameters = {
          frequency: frequency,
          tenseness: tenseness,
          loudness: loudness
        };
        Object.keys(parameters).forEach(function (parameterName) {
          _this2._container.dispatchEvent(new CustomEvent("setParameter", {
            bubbles: true,
            detail: {
              parameterName: parameterName,
              newValue: parameters[parameterName]
            }
          }));
        });
      }
    }
  }, {
    key: "node",
    get: function get() {
      return this._container;
    }
  }]);

  return GlottisUI;
}();

/* harmony default export */ var graphics_GlottisUI = (GlottisUI);
// CONCATENATED MODULE: ./script/graphics/ButtonsUI.js
function ButtonsUI_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ButtonsUI_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function ButtonsUI_createClass(Constructor, protoProps, staticProps) { if (protoProps) ButtonsUI_defineProperties(Constructor.prototype, protoProps); if (staticProps) ButtonsUI_defineProperties(Constructor, staticProps); return Constructor; }

/*
    TODO
        Toggle phonemes (voice/voiceless/none)
        refactor button creation
*/
var ButtonsUI =
/*#__PURE__*/
function () {
  function ButtonsUI() {
    ButtonsUI_classCallCheck(this, ButtonsUI);

    this._container = document.createElement("div");
    this._container.style.display = "flex";
    this._container.style.flexDirection = "column";
    this._buttons = {
      start: this._createButton("start"),
      wobble: this._createButton("wobble", true, "vibrato.wobble"),
      voice: this._createButton("voice", true, "intensity")
    };

    this._buttons.start.addEventListener("didResume", function (event) {
      event.target.parentElement.removeChild(event.target);
    });

    this._buttons.start.addEventListener("click", function (event) {
      event.target.dispatchEvent(new CustomEvent("resume", {
        bubbles: true
      }));
    });
  }

  ButtonsUI_createClass(ButtonsUI, [{
    key: "_createButton",
    value: function _createButton(buttonName) {
      var isParameter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var parameterPath = arguments.length > 2 ? arguments[2] : undefined;
      var button = document.createElement("button");
      button.id = buttonName;
      button.value = true;
      button.innerText = (isParameter ? "disable" : '') + buttonName;
      button.style.width = "100%";
      button.style.flex = 1;
      button.style.margin = "2px";
      button.style.borderRadius = "20px";
      button.style.backgroundColor = "pink";
      button.style.border = "solid red";

      this._container.appendChild(button);

      if (isParameter) {
        button.addEventListener("click", function (event) {
          button.value = button.value == "false";
          var prefix = button.value == "true" ? "disable" : "enable";
          button.innerText = prefix + ' ' + button.id;
          button.dispatchEvent(new CustomEvent("setParameter", {
            bubbles: true,
            detail: {
              parameterName: parameterPath || buttonName,
              newValue: button.value == "true" ? 1 : 0
            }
          }));
          button.dispatchEvent(new CustomEvent("message", {
            bubbles: true,
            detail: {
              type: "toggleButton",
              parameterName: buttonName,
              newValue: button.value
            }
          }));
        });
      }

      return button;
    }
  }, {
    key: "node",
    get: function get() {
      return this._container;
    }
  }]);

  return ButtonsUI;
}();

/* harmony default export */ var graphics_ButtonsUI = (ButtonsUI);
// CONCATENATED MODULE: ./script/graphics/PinkTromboneUI.js
function PinkTromboneUI_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function PinkTromboneUI_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function PinkTromboneUI_createClass(Constructor, protoProps, staticProps) { if (protoProps) PinkTromboneUI_defineProperties(Constructor.prototype, protoProps); if (staticProps) PinkTromboneUI_defineProperties(Constructor, staticProps); return Constructor; }

/*
    TODO
        .setFreqeuncyRange(min, max)
*/




var PinkTromboneUI_PinkTromboneUI =
/*#__PURE__*/
function () {
  function PinkTromboneUI() {
    var _this = this;

    PinkTromboneUI_classCallCheck(this, PinkTromboneUI);

    this._tractUI = new graphics_TractUI();
    this._glottisUI = new graphics_GlottisUI();
    this._buttonsUI = new graphics_ButtonsUI();
    this._container = document.createElement("div");
    this._container.style.height = "100%";
    this._container.style.width = "100%";
    this._container.style.display = "grid";
    this._container.style.gridTemplateRows = "auto 200px 100px";
    this._container.style.gridTemplateColumns = "auto 100px";
    this._container.style.gridRowGap = "5px";

    this._container.appendChild(this._tractUI.node);

    this._tractUI.node.id = "tractUI";
    this._tractUI.node.style.gridColumn = "1 / span 2";
    this._tractUI.node.style.gridRow = "1 / span 2";

    this._container.appendChild(this._glottisUI.node);

    this._glottisUI.node.id = "glottisUI";
    this._glottisUI.node.style.gridColumn = "1 / span 2";
    this._glottisUI.node.style.gridRow = "3";

    this._container.appendChild(this._buttonsUI.node);

    this._buttonsUI.node.id = "buttonsUI";
    this._buttonsUI.node.style.zIndex = 1;
    this._buttonsUI.node.style.gridColumn = "2";
    this._buttonsUI.node.style.gridRow = "2";

    this._container.addEventListener("message", function (event) {
      event.stopPropagation();
      Array.from(_this._container.children).forEach(function (child) {
        if (child !== event.target) {
          child.dispatchEvent(new CustomEvent("message", {
            detail: event.detail
          }));
        }
      });
    });
  }

  PinkTromboneUI_createClass(PinkTromboneUI, [{
    key: "show",
    value: function show() {
      this.node.style.display = "grid";
    }
  }, {
    key: "hide",
    value: function hide() {
      this.node.style.display = "none";
    }
  }, {
    key: "node",
    get: function get() {
      return this._container;
    }
  }]);

  return PinkTromboneUI;
}();

/* harmony default export */ var graphics_PinkTromboneUI = (PinkTromboneUI_PinkTromboneUI);
// CONCATENATED MODULE: ./script/component.js
function component_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { component_typeof = function _typeof(obj) { return typeof obj; }; } else { component_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return component_typeof(obj); }

function component_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function component_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function component_createClass(Constructor, protoProps, staticProps) { if (protoProps) component_defineProperties(Constructor.prototype, protoProps); if (staticProps) component_defineProperties(Constructor, staticProps); return Constructor; }

function component_possibleConstructorReturn(self, call) { if (call && (component_typeof(call) === "object" || typeof call === "function")) { return call; } return component_assertThisInitialized(self); }

function component_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function component_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) component_setPrototypeOf(subClass, superClass); }

function component_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; component_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !component_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return component_construct(Class, arguments, component_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return component_setPrototypeOf(Wrapper, Class); }; return component_wrapNativeSuper(Class); }

function component_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function component_construct(Parent, args, Class) { if (component_isNativeReflectConstruct()) { component_construct = Reflect.construct; } else { component_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) component_setPrototypeOf(instance, Class.prototype); return instance; }; } return component_construct.apply(null, arguments); }

function component_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function component_setPrototypeOf(o, p) { component_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return component_setPrototypeOf(o, p); }

function component_getPrototypeOf(o) { component_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return component_getPrototypeOf(o); }

/*
    TODO
        *
*/


window.AudioContext = window.AudioContext || window.webkitAudioContext;

var component_PinkTromboneElement =
/*#__PURE__*/
function (_HTMLElement) {
  component_inherits(PinkTromboneElement, _HTMLElement);

  function PinkTromboneElement() {
    var _this;

    component_classCallCheck(this, PinkTromboneElement);

    _this = component_possibleConstructorReturn(this, component_getPrototypeOf(PinkTromboneElement).call(this));
    _this._animationFrameObservers = [];
    window.customElements.whenDefined("pink-trombone").then(function () {
      // RequestAnimationFrame
      _this.addEventListener("requestAnimationFrame", function (event) {
        if (!_this._animationFrameObservers.includes(event.target)) _this._animationFrameObservers.push(event.target);
        var customEvent = new CustomEvent("didRequestAnimationFrame");
        event.target.dispatchEvent(customEvent);
        event.stopPropagation();
      });

      _this.addEventListener("resume", function (event) {
        _this.audioContext.resume();

        _this.pinkTrombone.start();

        event.target.dispatchEvent(new CustomEvent("didResume"));
      }); // Audio Parameters


      _this.addEventListener("setParameter", function (event) {
        var parameterName = event.detail.parameterName;
        var audioParam = parameterName.split('.').reduce(function (audioParam, propertyName) {
          return audioParam[propertyName];
        }, _this.parameters);
        var newValue = Number(event.detail.newValue);

        switch (event.detail.type) {
          case "linear":
            audioParam.linearRampToValueAtTime(newValue, _this.audioContext.currentTime + event.detail.timeOffset);
            break;

          default:
            audioParam.value = newValue;
        }

        event.target.dispatchEvent(new CustomEvent("didSetParameter", {
          detail: event.detail
        }));
        event.stopPropagation();
      });

      _this.addEventListener("getParameter", function (event) {
        var parameterName = event.detail.parameterName;
        var audioParam = parameterName.split('.').reduce(function (audioParam, propertyName) {
          return audioParam[propertyName];
        }, _this.parameters);
        var value = audioParam.value;
        var detail = event.detail;
        detail.value = value;
        event.target.dispatchEvent(new CustomEvent("didGetParameter", {
          detail: detail
        }));
        event.stopPropagation();
      }); // Constrictions


      _this.addEventListener("newConstriction", function (event) {
        var _event$detail = event.detail,
            index = _event$detail.index,
            diameter = _event$detail.diameter;

        var constriction = _this.newConstriction(index, diameter);

        var detail = event.detail;
        detail.constrictionIndex = constriction._index;
        event.target.dispatchEvent(new CustomEvent("didNewConstriction", {
          detail: detail
        }));
        event.stopPropagation();
      });

      _this.addEventListener("setConstriction", function (event) {
        var constrictionIndex = Number(event.detail.constrictionIndex);
        var constriction = _this.constrictions[constrictionIndex];

        if (constriction) {
          var _event$detail2 = event.detail,
              index = _event$detail2.index,
              diameter = _event$detail2.diameter;
          var indexValue = index || constriction.index.value;
          var diameterValue = diameter || constriction.diameter.value;

          switch (event.detail.type) {
            case "linear":
              constriction.index.linearRampToValueAtTime(indexValue, event.detail.endTime);
              constriction.diameter.linearRampToValueAtTime(diameterValue, event.detail.endTime);
              break;

            default:
              constriction.index.value = indexValue;
              constriction.diameter.value = diameterValue;
          }

          event.target.dispatchEvent(new CustomEvent("didSetConstriction"));
        }

        event.stopPropagation();
      });

      _this.addEventListener("getConstriction", function (event) {
        var constrictionIndex = Number(event.detail.constrictionIndex);
        var constriction = _this.constrictions[constrictionIndex];
        event.target.dispatchEvent(new CustomEvent("didGetConstriction", {
          detail: {
            index: constriction.index.value,
            diameter: constriction.diameter.value
          }
        }));
        event.stopPropagation();
      });

      _this.addEventListener("removeConstriction", function (event) {
        var constrictionIndex = Number(event.detail.constrictionIndex);
        var constriction = _this.constrictions[constrictionIndex];

        _this.removeConstriction(constriction);

        var detail = event.detail;
        event.target.dispatchEvent(new CustomEvent("didRemoveConstriction", {
          detail: detail
        }));
        event.stopPropagation();
      });

      _this.addEventListener("getProcessor", function (event) {
        _this.getProcessor().then(function (processor) {
          event.target.dispatchEvent(new CustomEvent("didGetProcessor", {
            detail: {
              processor: processor
            }
          }));
        });

        event.stopPropagation();
      });
    });
    if (_this.getAttribute("UI") !== null) _this.enableUI();
    var loadEvent = new Event("load");

    _this.dispatchEvent(loadEvent);

    return _this;
  }

  component_createClass(PinkTromboneElement, [{
    key: "enableUI",
    value: function enableUI() {
      if (this.UI == undefined) {
        this.UI = new graphics_PinkTromboneUI();
        this.appendChild(this.UI.node);
      }

      this.UI.show();
    }
  }, {
    key: "disableUI",
    value: function disableUI() {
      if (this.UI !== undefined) {
        this.UI.hide();
        this.stopUI();
      }
    }
  }, {
    key: "startUI",
    value: function startUI() {
      var _this2 = this;

      if (this.UI !== undefined) {
        this._isRunning = true;
        window.requestAnimationFrame(function (highResTimeStamp) {
          _this2._requestAnimationFrameCallback(highResTimeStamp);
        });
      }
    }
  }, {
    key: "stopUI",
    value: function stopUI() {
      this._isRunning = false;
    } // getAttribute getter?

  }, {
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(name, oldValue, newValue) {
      switch (name) {
        case "UI":
          if (newValue !== null) this.enableUI();else this.disableUI();
          break;

        default:
          break;
      }
    }
  }, {
    key: "setAudioContext",
    value: function setAudioContext() {
      var _this3 = this;

      var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new window.AudioContext();
      this.pinkTrombone = audioContext.createPinkTrombone();
      this.loadPromise = this.pinkTrombone.loadPromise.then(function (audioContext) {
        _this3.parameters = _this3.pinkTrombone.parameters;

        for (var parameterName in _this3.pinkTrombone.parameters) {
          _this3[parameterName] = _this3.pinkTrombone.parameters[parameterName];
        }

        return _this3.pinkTrombone;
      });
      return this.loadPromise;
    }
  }, {
    key: "connect",
    value: function connect() {
      var _this$pinkTrombone;

      if (this.pinkTrombone) return (_this$pinkTrombone = this.pinkTrombone).connect.apply(_this$pinkTrombone, arguments);
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      var _this$pinkTrombone2;

      if (this.pinkTrombone) return (_this$pinkTrombone2 = this.pinkTrombone).disconnect.apply(_this$pinkTrombone2, arguments);
    }
  }, {
    key: "start",
    value: function start() {
      if (this.pinkTrombone) {
        this.pinkTrombone.start();
        this.startUI();
      } else throw "Pink Trombone hasn't been set yet";
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this.pinkTrombone) {
        this.pinkTrombone.stop();
        this.stopUI();
      } else throw "Pink Trombone hasn't been set yet";
    }
  }, {
    key: "_requestAnimationFrameCallback",
    value: function _requestAnimationFrameCallback(highResTimeStamp) {
      var _this4 = this;

      if (this._isRunning) {
        this._animationFrameObservers.forEach(function (element) {
          var customEvent = new CustomEvent("animationFrame", {
            detail: {
              highResTimeStamp: highResTimeStamp
            }
          });
          element.dispatchEvent(customEvent);
        });

        window.requestAnimationFrame(function (_highResTimeStamp) {
          return _this4._requestAnimationFrameCallback.call(_this4, _highResTimeStamp);
        });
      }
    } // CONSTRICTIONS

  }, {
    key: "newConstriction",
    value: function newConstriction() {
      var _this$pinkTrombone3;

      return (_this$pinkTrombone3 = this.pinkTrombone).newConstriction.apply(_this$pinkTrombone3, arguments);
    }
  }, {
    key: "removeConstriction",
    value: function removeConstriction(constriction) {
      return this.pinkTrombone.removeConstriction(constriction);
    }
  }, {
    key: "getProcessor",
    value: function getProcessor() {
      return this.pinkTrombone.getProcessor();
    }
  }, {
    key: "audioContext",
    get: function get() {
      if (this.pinkTrombone) return this.pinkTrombone.audioContext;else throw "Audio Context has not been set";
    },
    set: function set(audioContext) {
      this.setAudioContext(audioContext);
    }
  }, {
    key: "constrictions",
    get: function get() {
      return this.pinkTrombone.constrictions;
    }
  }], [{
    key: "observedAttributes",
    get: function get() {
      return ["UI"];
    }
  }]);

  return PinkTromboneElement;
}(component_wrapNativeSuper(HTMLElement));

if (document.createElement("pink-trombone").constructor == HTMLElement) {
  window.customElements.define("pink-trombone", component_PinkTromboneElement);
}

/* harmony default export */ var component = __webpack_exports__["default"] = (component_PinkTromboneElement);

/***/ })
/******/ ]);
//# sourceMappingURL=pink-trombone.min.js.map